# **Respuestas Teóricas**

## Sobre implementar funcionalidad:
##### 1)  Los tests 01, 02 y 03 demuestran la funcionalidad de cómo se incrementa la cantidad de huevos de avispas a medida que los van dejando. Cuando los implementaste, ¿esos tests pasaron (los tres) de una? ¿podrías haber implementado esta funcionalidad de a partes, haciendo que pase el 01, luego el 01 y el 02 y por último el 01, 02 y 03? ¿se te ocurre cómo? Y si lograste hacerlo, ¿qué pensas de implementar esa funcionalidad de esa forma?
Para los test 01, 02 y 03 lo que hicimos fue que pasen de a uno pero secuencialmente, es decir, primero implementamos la funcionalidad pedida para el primero (que la cantidad de huevos de avispas sea 0), verificamos que pasara y luego fuimos a la segunda. En esta, nos pedía que sea 1, entonces lo modificamos para que sea 1. Al hacer esto, y correr las dos pruebas a la vez, claramente la primera dejó de andar, es por eso que nos dimos cuenta que debíamos implementar el método de manera que al reproducirse las avispas, se aumente en 1 la cantidad de huevos puestos que lo declaramos como un colaborador del hábitat. Esto permitió a su vez, que la prueba 3 pase sin tener que modificar nada.
Respecto a esta forma de implementar esa funcionalidad, pensamos que nos benefició porque fuimos pensando el código de a pasos según lo requerido. Además si la única prueba hubiese sido que devuelva 0, esta manera de programar nos hubiera ahorrado implementar una funcionalidad que no se pedía en las pruebas, ya que con que devuelva 0 bastaría.
# Sobre código repetido
##### 2) ¿Les quedó código repetido? ¿dónde? ¿Se animan a adivinar qué cosa del dominio les faltó representar (y por eso tienen código repetido)? Responsabilidad de dejar un huevo consumiendo otro insecto ¿Quién les quedó, en su modelo, que es el responsable de ver si hay suficientes polillas u orugas y entonces dejar un huevo? ¿el insecto (Polly, Oriana, etc) o el hábitat? ¿por qué? ¿por qué tendría sentido que fuera de la otra forma? ¿con cuál nos quedamos?
Nos estaba por quedar código repetido cuando quisimos implementar el objeto de LaAvispaOrnella pero nos dimos cuenta que compartía los mismos métodos y colaboradores que LaAvispaOriana, por lo tanto, la creamos como hija de esta. Donde sí nos quedó código repetido fue en la parte de reiniciar los huevos, pero consideramos que modularizarlo nos iba a generar colaboraciones extra innecesariamente y que es más claro dejarlo así.
Revisando nuestro modelo, creemos que representamos todo lo necesario para cumplir con las funcionalidades pedidas, y no creemos que sea necesario modelar más elementos del dominio que no se utilicen, porque no estaríamos acotándonos al recorte de la realidad que hicimos.
Al momento de reproducirse, la responsable de ver si hay suficientes polillas u orugas para hacerlo es la avispa, pero comunicándose con el hábitat que es quien sabe la cantidad de las mismas que hay disponible. Si las hay, deja el huevo en el hábitat. Creemos que no tiene mucho sentido que fuera la avispa quien lleve un registro de los recursos necesarios para reproducirse, debido a que para que esto suceda tendríamos que definir colaboradores internos de los mismos para cada avispa, lo cual no estaría bien porque los insectos para alimentarse son del hábitat. Por esto último le dejamos la responsabilidad al hábitat.
# Sobre código repetido 2
##### 3) Con lo que vimos en la clase del Jueves (en la parte teórica, prototipos vs clases) ¿cómo sacarían este código? Sobre la implementación ¿cómo resolvieron guardar los huevos? ¿Usaron colecciones? ¿Diccionarios? ¿Uno, varios? ¿con qué indexaban? Pero la pregunta más importante: ¿es lo más sencillo que hacía falta? ¿o se podía hacer menos y todo andaba?
Entendemos que con la primer pregunta refiere al comportamiento de Ornella respecto a Oriana, que con lo visto en clase identificamos que al ser muy similares podíamos aplicar el concepto de prototipos haciendo a Ornella una avispa "hija" de la otra.
El tema de los huevos, lo resolvimos usando un diccionario de par clave-valor dado por firma genética - cantidad de huevos, que al reiniciar el hábitat se reemplaza por uno nuevo vacío (con 0 huevos cada clave). Para indexar el mismo, utilizamos la firma genética la cual representamos como la incial de cada avispa. Al principio habíamos utilizado como clave el nombre completo de cada avispa, pero como Ornella y Oriana comparten firma, decidimos cambiarla a la inicial para que no parezca que cuando Oriana pone huevos, se interpreten explicitamente como los mismos de Ornella. Nos pareció que usando la 'O' podíamos englobar a ambas a la vez.
Quizás no hacía falta usa un diccionario, ya que podríamos haberlo implementado con colaboradores internos para cada avispa (y en el caso de Oriana y Ornella sumar la cantidad de huevos de cada una). Sin embargo, consideramos que al utilizar el diccionario, bajamos el acoplamiento, es decir, bajamos la cantidad de colaboraciones.